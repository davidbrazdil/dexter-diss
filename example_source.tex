\section{Source\_Browser.java}

\begin{lstlisting}
public class Source_Browser extends FallbackInstrumentor {

  /*
   *  Apply instrumentation only if the instruction calls:
   *  - Cursor android.provider.Browser.getAllBookmarks(ContentResolver cr), or
   *  - Cursor android.provider.Browser.getAllVisitedUrls(ContentResolver cr)
   *  Both of these are declared 'public static final'.
   */
  @Override
  public boolean canBeApplied(DexPseudoinstruction_Invoke insn) {
    val insnInvoke = insn.getInstructionInvoke();

    val callType = insnInvoke.getCallType();
    val className = insnInvoke.getClassType().getDescriptor();
    val methodName = insnInvoke.getMethodName();
    val methodPrototype = insnInvoke.getMethodPrototype();
    val methodReturnType = methodPrototype.getReturnType().getDescriptor();
    val methodParameters = methodPrototype.getParameterTypes();

    return insn.movesResult() && // only instrument if result is used
           callType == Opcode_Invoke.Static &&
           className.equals("Landroid/provider/Browser;") &&
           (methodName.equals("getAllBookmarks") || 
           	methodName.equals("getAllVisitedUrls")) &&
           methodReturnType.equals("Landroid/database/Cursor;") &&
           methodParameters.size() == 1 &&
           methodParameters.get(0).getDescriptor().equals(
           	"Landroid/content/ContentResolver;");
  }

  /*
   * Generate Browser source instrumentation.
   */
  @Override
  public Pair<List<DexCodeElement>, List<DexCodeElement>> generateInstrumentation(
      DexPseudoinstruction_Invoke insn, DexCode_InstrumentationState state) {
    val code = insn.getMethodCode();

    /*
     * generate default external call instrumentation,
     * because it automatically handles exceptions
     */
    val defaultInstrumentation = super.generateDefaultInstrumentation(
      insn, state,
      Collections.<Integer> emptySet(), // collect taint of the argument
      Arrays.asList(0),                 // do not propagate taint into the argument
      false);                           // assign taint to the result
    val codeBefore = defaultInstrumentation.getValA();
    val codeAfter = defaultInstrumentation.getValB();

    // set the Browser flag in the combined taint of the method call
    val instrumentation = new ArrayList<DexCodeElement>(2);
    instrumentation.add(new DexInstruction_BinaryOpLiteral(
      code, 
      regCombinedTaint, regCombinedTaint, TaintConstants.TAINT_SOURCE_BROWSER, 
      Opcode_BinaryOpLiteral.Or));
    instrumentation.add(new DexMacro_PrintStringConst(
      code, "browser data => " + TaintConstants.TAINT_SOURCE_BROWSER, true));

    // insert instrumentation right after the method call
    codeAfter.addAll(0, instrumentation);

    return new Pair<>(codeBefore, codeAfter);
  }
}
\end{lstlisting}

\section{LiveVarAnalysis.java}

\begin{lstlisting}
public class LiveVarAnalysis {

  @Getter private final DexCode code;
  private Map<DexCodeElement, Set<DexRegister>> liveVarsOut;
  private Map<DexCodeElement, Set<DexRegister>> liveVarsIn;

  public LiveVarAnalysis(DexCode code) {
    this.code = code;
    generateLVA();
  }

  private void generateLVA() {
    val CFG = new ControlFlowGraph(code);
    val basicBlocks = CFG.getBasicBlocks();

    // create tables that will hold variable lists
    liveVarsOut = new HashMap<DexCodeElement, Set<DexRegister>>();
    liveVarsIn = new HashMap<DexCodeElement, Set<DexRegister>>();
    
    // initialize variable lists
    for (val insn : code.getInstructionList())
      liveVarsOut.put(insn, new HashSet<DexRegister>());

    // propagate and combine lists until convergence
    boolean somethingChanged;
    do {
      somethingChanged = false;

      // iterate through basic blocks in reverse order (converges faster)
      for (val block : new ListReverser<CfgBasicBlock>(basicBlocks)) {

    	// combine variable lists of successors   
        Set<DexRegister> insnLiveIn = new HashSet<>();
        for (val succ : block.getSuccessors())
          if (succ instanceof CfgBasicBlock)
            insnLiveIn.addAll(liveVarsOut.get(
            	((CfgBasicBlock) succ).getFirstInstruction()));

        // propagate the variable list backwards 
        // through the instructions of the basic block 
        for (val insn : new ListReverser<DexCodeElement>(block.getInstructions())) {
        	
          // store the list coming to the instruction from successors
          liveVarsIn.put(insn, insnLiveIn);

          // acquire the variable list of this instruction  
          val insnLiveOut = liveVarsOut.get(insn);
          int insnLiveOut_PrevSize = insnLiveOut.size();

          // add the incoming vars, remove defined and add referenced
          insnLiveOut.addAll(insnLiveIn);
          insnLiveOut.removeAll(insn.lvaDefinedRegisters());
          insnLiveOut.addAll(insn.lvaReferencedRegisters());

          // if size of the var list changed, something was added
          if (insnLiveOut_PrevSize < insnLiveOut.size())
            somethingChanged = true;

          // pass the list to the preceding instruction
          insnLiveIn = insnLiveOut;
        }
      }
    } while (somethingChanged);
  }

  public Set<DexRegister> getLiveVarsBefore(DexCodeElement insn) {
    return liveVarsOut.get(insn);
  }

  public Set<DexRegister> getLiveVarsAfter(DexCodeElement insn) {
    return liveVarsIn.get(insn);
  }
}
\end{lstlisting}
